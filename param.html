<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>パラメータ確認</title>
	</head>
	<body>
		<h1>パラメータ確認 flash2</h1>
        <video autoplay></video>
        <!--<input type="range" id="rangezoom" hidden>-->
        <p>zoom <input type="range" id="rangezoom"></p>
        <p>解像度 <input type="range" id="rangeres"></p>
        <div>
            <canvas id='takePhotoCanvas'></canvas>
            <button id='takePhotoButton' disabled>Take Photo</button>
        </div>
        
        <h3>Output</h3>
        <div id="output"></div>

        
<script>
//    window.onload = function() {
//        document.querySelector('#log').textContent = 'aaaaauoeadf';
//    };
    outputTEST('start.');

    var imageCapture;
    navigator.mediaDevices.getUserMedia({video: true})
    .then(async mediaStream => {
        outputTEST('gotMedia start');
        document.querySelector('video').srcObject = mediaStream;
        // 待つ必要がある(バグらしい↓)
        // crbug.com/711524
        await sleep(1000);

        const mediaStreamTrack = mediaStream.getVideoTracks()[0];
        
        const capabilities = mediaStreamTrack.getCapabilities();
        const settings = mediaStreamTrack.getSettings();
        // if (capabilities.zoom) {
        //     outputTEST('false capabilities.zoom:' + capabilities.zoom);
        // }
        // if (!('zoom' in capabilities)) {
        //     outputTEST('in not capabilities.zoom:' + capabilities.zoom);
        // }else{
        //     outputTEST('in capabilities.zoom:' + capabilities.zoom);
        // }
        
        outputTEST('* capabilities:' + capabilities);
        for(key in capabilities){
            outputTEST(key + ': ' + capabilities[key])
        }
        outputTEST('*');
        
        outputTEST('* settings:' + capabilities);
        for(key in settings){
            outputTEST(key + ': ' + settings[key])
        }
        outputTEST('*');
        
        imageCapture = new ImageCapture(mediaStreamTrack);
        console.log(imageCapture);
        
        // zoom
        var zoomSlider = document.getElementById('rangezoom');
        if (capabilities.zoom) {
            zoomSlider.min = capabilities.zoom.min;
            zoomSlider.max = capabilities.zoom.max;
            zoomSlider.step = capabilities.zoom.step;
            zoomSlider.value = settings.zoom;
            zoomSlider.oninput = function(event) {
                mediaStreamTrack.applyConstraints({advanced: [ {zoom: event.target.value} ]})
                .catch(error => console.error('applyConstraints() error:', error));
            }
        }
        
        // torch
        if (capabilities.torch) {
            track.applyConstraints({advanced: [{torch: true}]})
            .catch(e => console.log(e));
            outputTEST('torch on.')
        }else{
            outputTEST('not torch.')
        }
        outputTEST('gotMedia end');
    })
    .catch(error => console.error('getUserMedia() error:', error));
    
    function onTakePhotoButtonClick() {
        imageCapture.takePhoto({ fillLightMode : 'flash' })
        .then(blob => createImageBitmap(blob))
        .then(imageBitmap => {
            const canvas = document.querySelector('#takePhotoCanvas');
            drawCanvas(canvas, imageBitmap);
        })
        .catch(error => console.error('takePhoto() error:', error));
    }

/* Utils */
    function outputTEST(msg) {
        document.querySelector('#output').innerHTML += '<div>' + msg + '<div>';
    }
    
    function sleep(ms = 0) {
        return new Promise(r => setTimeout(r, ms));
    }
    function drawCanvas(canvas, img) {
        canvas.width = getComputedStyle(canvas).width.split('px')[0];
        canvas.height = getComputedStyle(canvas).height.split('px')[0];
        let ratio  = Math.min(canvas.width / img.width, canvas.height / img.height);
        let x = (canvas.width - img.width * ratio) / 2;
        let y = (canvas.height - img.height * ratio) / 2;
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        canvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height,
            x, y, img.width * ratio, img.height * ratio);
    }
    
    document.querySelector('#takePhotoButton').addEventListener('click', onTakePhotoButtonClick);
    document.querySelector('video').addEventListener('play', function() {
        document.querySelector('#takePhotoButton').disabled = false;
    })
//    navigator.mediaDevices.getUserMedia({video: true})
//    .then(async mediaStream => {
//      document.querySelector('video').srcObject = mediaStream;
//
//      // Once crbug.com/711524 is fixed, we won't need to wait anymore. This is
//      // currently needed because capabilities can only be retrieved after the
//      // device starts streaming. This happens after and asynchronously w.r.t.
//      // getUserMedia() returns.
//      await sleep(1000);
//
//      const track = mediaStream.getVideoTracks()[0];
//      const capabilities = track.getCapabilities();
//      const settings = track.getSettings();
//        
//      outputTEST('getCapabilities.');
//      //const input = document.querySelector('input[type="range"]');
//      const input = document.getElementById('rangezoom');
//
//      // Check whether zoom is supported or not.
//      if (!('zoom' in capabilities)) {
//          outputTEST('Zoom is not supported.' + track.label);
////          return Promise.reject('Zoom is not supported by ' + track.label);
//      }else{
//          outputTEST('Zoom is supported.' + track.label);
//      }
//        
//    })
    
    
    //var str = document.querySelector('#output').textContent;
    outputTEST('end.');

</script>

	</body>
</html>